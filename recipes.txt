% AMBA - SoC안에서 IP끼리의 Bus규격
AMBA : Bus들을 어떻게 연결하고, IP끼리 서로 어떻게 통신 할 것이냐를 약속한 것
	Bus Interface : Bus위에 Data를 어떻게 전송할 것이냐, 어떻게 받을거냐를 잘 control해주는 interface – AHB / ASB / APB
	  
% ARM Register 와 Context
Banked Register : Mode별로 따로 가지고 있는 Register
Thumb mode : R0 ~ R7
ARM mode : R0 ~ R12

% ARM 동작 Modes
Normal Mode - USR
Privileged Mode – SYS / SVC / IRQ / FIQ / ABT / UND
	Interrupt의 사용 가능 유무를 직접 설정
	서로 Mode변경이 자유롭다
ARM의 Default Mode? SVC mode에서 출발(or Reset)해야 boot up시에 ARM에 대한 모든 권한을 행사

% RAM Memory의 물리적 동작
	Address Bus Width가 16bit이면 최대로 나타낼 수 있는 Memory Size는 얼마인가?
	2^16만큼 Address를 표현 64KB -> 16bit씩 access하는 system에서는 얼마나 큰 Address 크기를 나타낼 수 있을까요? -> 2배하면 된다. 128KB

% Memory의 선정과 XIP
	XIP(Execute In Place) – 메모리 상에서 직접 program/code를 실행할 수 있는 기술
		Random Access가 가능해야한다. 
		Word단위의 Access가 가능하여 Software를 Execution할 수 있는 것.
		RAM / NOR flash
	eMMC는 XIP기능이 있는가?

	DRAM : 일정 시간마다 다시 전하를 충전해줘야 Data를 잃어버리지 않는다. (사용자설정)
	DDR(Double Data Rate) – Bus Clock의 rising/falling edge에서 모두 동작-두배로 빠르다.
	Synchronous – System Bus의 Clock으로 동기를 맞춘다. (거의 CPU의 동작에 맞추어 동작한다.)
	ROM – Flash Memory(Burning이 가능)

% Pull up, Pull down 그리고 Open Collector
  Low Active : 0에서 동작 : CS/, CS_N, CS* ...
    Pull-up : default 1 (전원쪽에 저항)
  High Active : 1에서 동작 : CS
    Pull-down : default 0 (GND쪽에 저항)
    
  Gate모임들을 프로그래밍 -> VHDL/verilog -> chip -> FPGA

% 초간단 회로이론 R 저항 L 인덕터 C 캐패시터
  저항 : 특정부분에 흐르는 전류의 양을 제한 / 전압 감소 
    	R이 클수록 전류를 더 조금 흐르게 할 수 있다.
  캐피시터(C) : 높은 주파수의 전압 일수록 저항을 못 느낀다. - 단위 패럿
    	C가 작을수록 전류는 더 조금 흐르게 할 수 있다.
    	AC입장에서 보면 Short나 다름없다.
    	Low Pass Filter - DC만 흐른다. (AC를 GND로 흐르게 한다)
		전원이 켜질 때 Transition으로 생기는 Noise따위를 제거하기 위한 것…- Ripple제거
  인덕터(L) : 높은 주파수의 전류일수록 저항을 더 크게 느낀다. – 
저주파의 전류만 통과 - 급격한 신호의 흐름을 막는다. - 단위 H 헨리
    	L이 클수록  전류는 더 조금 흐르게 합니다.
    	AC입장에서 보면 Open이다.

  Open / Short : 연결되어 있지 않다/연결 되어 있다.
  
% Analog 신호와 Digital신호, 그리고 Ground
  high Impedance / floating : 무슨 값이 될지 모르는 상태. 
    이 상태의 PIN은 다른 칩들에 의해서 유기 되어진 버스상의 값들의 변화에 관여하지 않는다.
  Capacitor : 이것을 POWER line에 달아 전압/전류가 순간적으로 낮아질때 Capacitor가 저장하고 있던 전기에너지를 방출하여 
    Power line의 전압을 원래대로 유지하는 용도로. - Decoupling condenser/Bypass condenser
    Decoupling Capacitor : Noise/Ripple 성분을 전원공급에서 떼내어 버린다는 것을 뜻한다.
    Bypass Capacitor : Noise/Ripple성분을 주파수 특성을 이용하여 GND로 통과시켜버린다는 의미

% 단위와 수량
  p : pico / 10^-12
  n : nano / 10^-9
  u : micro / 10^-6
  m : milli / 10^-3
  k : kilo / 10^3
  M : mega / 10^6

  2^20 : 1 MB
  2^10 : 1 KB
  2^16 : 64 KB
  
  20 KHz = 1/20 KHz -> 50 us 마다 한번식 다시 0으로 돌아온다.
  
  Amplitude : 크기 또는 높이
  

% MMU (Memory Management Unit)
  1. Task 마다 또는 프로그램 마다 똑같은 주소를 사용해도 되게 만들어 준다.
  2. 두개의 CS를 사용하는 RAM의 물리적 주소가 CS1:0x00000~0x10000, CS2:0x20000~0x30000 이렇게 나뉘어져 있어도 MMU만 잘 사용하면
  0x00000~0x20000으로 연속적인 것처럼 사용할 수 있다.
  3. Physical Address상에서는 쓰고 남은 조각조각 난 Memory들을 한데 모아서 마치 연속적인 Memory처럼 사용할 수도 있다.
  4. CPU-(Virtual Address)->MMU->(Physical Address)->Memory
  5. Memory영역의 특성을 조작(Cache/Non Cache/Write Bufferable/Non Write Bufferable/ReadOnly)
  6. TTB(Translation Table Base Address)
  7. Linux - 물리 주소를 가상 주소로 매핑하는 방법
    1.	mmap() – 응용 프로그램의 프로세스 가상 주소에 매핑
    2.	ioremap() – MMU가 활성화되어 있는 커널모드 - 디바이스 드라이버에서 물리주소를 커널의 가상주소로 매핑하는 방법
    3. copy_to_user/copy_from_user : 커널모드에서 사용자 메모리 공간 접근 방법.

% 낸드플래시가 뭐죠
  낸드 플래시의 인터널 램 - 낸드 플래시에 있는 부트로더를 동작시키는 일
  부트로더는 낸드에 있는 바이너리를 SDRAM에 로딩.
  
  
% Bootloader와 Memory Budget (Mapfile) 어떻게 변수초기화를 할 것인다.
  Loader - ROM에서 RAM으로 뭔가를 싣는다.
  Boot Loader - HW 초기화 / RAM으로 로딩
  MCP - Multi Chip Package
  ROM : RO - code와 const data / RW - 초기값이 있는 Global변수
    Scatter loading - Load View : Load$$ROM$$
  RAM : ZI-Dynamic하게 생성. / RW / RO는 메모리에 따라 NAND의 경우엔 RAM에 복사
    Scatter loading - Execution View : Image$$RAM_1$$

% Pointer와 Array는 소녀시대와 원더걸스 , 그리고 이중포인터

이중 pointer는 Pointer를 가리키는 Pointer라는 뜻이고요, 
실은 Pointer도 메모리 어딘가에 자리 잡고 있는 변수 인 거에요.

pointer를 함수의 passing parameter로 제대로 넘겨 주려면 pointer의 주소를 넘겨주고, 
이중 pointer로 받아 주어야 그 주소를 제대로 넘겨 받을 수 있게 되는 거지요. 

  void gettag (char **ptag)
  {
    *ptag=(char *)malloc(40);
    strncpy(*ptag,"pointer tag", sizeof(char)*40);
  }
 
  void process()
  {
    char *tag;
 
    gettag(&tag);
    free(tag);
  }

% Stack의 정체와 자세히 보기 - initialization까지

보통 사용하는 stack은 Full Descending으로 구현되어, 
더 낮은 주소로 Stack이 자라고, SP가 가리키는 주소는 Valid Data를 품고 있다.

  stmdb r9!, (r0,r1,r5) == stmfd 
  /* 
    (r5 -> r1 -> r0 : r9는 r0를 가리키고 있다.)
    하지만 Memory 값을 생각해보면 (Jtag같은데서)...
                        0        4        8  
    0x1f6e9390 : 00000000 00000001 00000002
                       r0       r1       r5    
  */  
  ARM state - stack 관련 Multiple Register Transfer / BL
  Thumb state - Push/Pop / BLX
  
  push {r4, r14}
  ...
  pop {r4, r14}

일반 Symbol과는 달리 로컬변수는 달리 Stack에 저장되니깐 개인 Address가 없다. 그래서 함수 내에서만 유지된다.
Symbol이라 함은 Physical 주소를 점유 - 함수의 이름

int (* function)(int a);
int recipe(int a)
  function = recipe or &recipe // recipe() - X

int (* function[4])(int, int) = { plus, minus, multiply, divide }
  function[2](1,3) -> multiply(1,3)


% RTOS 와 Kernel
RTOS - 기본적으로 Multi Tasking과 Interrupt 처리 기능을 가진다. 
  Hard : 응답시간 자체가 Functional Requirement가 됩 - 보통 군사용 기기
  Soft : 최대한 빨리 응답하기만 하면 요구사항을 맞출 수 있다. - 보통 우리가 다루는 RTOS
    리눅스도 Preemption Scheduling Policy 채용

% Task 구조와 Signal
Task > Process, Task > Thread
Process는 자신 만의 고유한 Memory Space를 할당받는다.
Thread는 모든 주소 공간이 공유






