% Pull up, Pull down 그리고 Open Collector
  Low Active : 0에서 동작 : CS/, CS_N, CS* ...
    Pull-up : default 1 (전원쪽에 저항)
  High Active : 1에서 동작 : CS
    Pull-down : default 0 (GND쪽에 저항)
    
  Gate모임들을 프로그래밍 -> VHDL/verilog -> chip -> FPGA

% 초간단 회로이론 R 저항 L 인덕터 C 캐패시터
  저항 : 특정부분에 흐르는 전류의 양을 제한 / 전압 감소 
    R이 클수록 전류를 더 조금 흐르게 할 수 있다.
  캐피시터 : 높은 주파수의 전압 일수록 저항을 못 느낀다. - 단위 패럿
    C가 작을수록 전류는 더 조금 흐르게 할 수 있다.
    AC입장에서 보면 Short나 다름없다.
    Low Pass Filter - DC만 흐른다.
  인덕터 : 높은 주파수의 전류일수록 저항을 더 크게 느낀다. - 저주파의 전류만 통과 - 급격한 신호의 흐름을 막는다. - 단위 H 헨리
    L이 클수록  전류는 더 조금 흐르게 합니다.
    AC입장에서 보면 Open이다.

  Open / Short : 연결되어 있지 않다/연결 되어 있다.
  
% Analog 신호와 Digital신호, 그리고 Ground
  high Impedance / floating : 무슨 값이 될지 모르는 상태. 
    이 상태의 PIN은 다른 칩들에 의해서 유기 되어진 버스상의 값들의 변화에 관여하지 않는다.
  Capacitor : 이것을 POWER line에 달아 전압/전류가 순간적으로 낮아질때 Capacitor가 저장하고 있던 전기에너지를 방출하여 
    Power line의 전압을 원래대로 유지하는 용도로. - Decoupling condenser/Bypass condenser

% 단위와 수량
  p : pico / 10^-12
  n : nano / 10^-9
  u : micro / 10^-6
  m : milli / 10^-3
  k : kilo / 10^3
  M : mega / 10^6
  
  20 KHz = 1/20 KHz -> 50 us 마다 한번식 다시 0으로 돌아온다.
  
  Amplitude : 크기 또는 높이
  

% MMU (Memory Management Unit)
  1. Task 마다 또는 프로그램 마다 똑같은 주소를 사용해도 되게 만들어 준다.
  2. 두개의 CS를 사용하는 RAM의 물리적 주소가 CS1:0x00000~0x10000, CS2:0x20000~0x30000 이렇게 나뉘어져 있어도 MMU만 잘 사용하면
  0x00000~0x20000으로 연속적인 것처럼 사용할 수 있다.
  3. Physical Address상에서는 쓰고 남은 조각조각 난 Memory들을 한데 모아서 마치 연속적인 Memory처럼 사용할 수도 있다.
  4. CPU-(Virtual Address)->MMU->(Physical Address)->Memory
  5. Memory영역의 특성을 조작(Cache/Non Cache/Write Bufferable/Non Write Bufferable/ReadOnly)
  6. TTB(Translation Table Base Address)
  7. Linux - 물리 주소를 가상 주소로 매핑하는 방법
    1.	mmap() – 응용 프로그램의 프로세스 가상 주소에 매핑
    2.	ioremap() – MMU가 활성화되어 있는 커널모드 - 디바이스 드라이버에서 물리주소를 커널의 가상주소로 매핑하는 방법
    3. copy_to_user/copy_from_user : 커널모드에서 사용자 메모리 공간 접근 방법.

% 낸드플래시가 뭐죠
  낸드 플래시의 인터널 램 - 낸드 플래시에 있는 부트로더를 동작시키는 일
  부트로더는 낸드에 있는 바이너리를 SDRAM에 로딩.
  
  
% Bootloader와 Memory Budget (Mapfile) 어떻게 변수초기화를 할 것인다.
  Loader - ROM에서 RAM으로 뭔가를 싣는다.
  Boot Loader - HW 초기화 / RAM으로 로딩
  MCP - Multi Chip Package
  ROM : RO - code와 const data / RW - 초기값이 있는 Global변수
    Scatter loading - Load View : Load$$ROM$$
  RAM : ZI-Dynamic하게 생성. / RW / RO는 메모리에 따라 NAND의 경우엔 RAM에 복사
    Scatter loading - Execution View : Image$$RAM_1$$

% Pointer와 Array는 소녀시대와 원더걸스 , 그리고 이중포인터

이중 pointer는 Pointer를 가리키는 Pointer라는 뜻이고요, 
실은 Pointer도 메모리 어딘가에 자리 잡고 있는 변수 인 거에요.

pointer를 함수의 passing parameter로 제대로 넘겨 주려면 pointer의 주소를 넘겨주고, 
이중 pointer로 받아 주어야 그 주소를 제대로 넘겨 받을 수 있게 되는 거지요. 

  void gettag (char **ptag)
  {
    *ptag=(char *)malloc(40);
    strncpy(*ptag,"pointer tag", sizeof(char)*40);
  }
 
  void process()
  {
    char *tag;
 
    gettag(&tag);
    free(tag);
  }

% Stack의 정체와 자세히 보기 - initialization까지

보통 사용하는 stack은 Full Descending으로 구현되어, 
더 낮은 주소로 Stack이 자라고, SP가 가리키는 주소는 Valid Data를 품고 있다.

  stmdb r9!, (r0,r1,r5) == stmfd 
  /* 
    (r5 -> r1 -> r0 : r9는 r0를 가리키고 있다.)
    하지만 Memory 값을 생각해보면 (Jtag같은데서)...
                        0        4        8  
    0x1f6e9390 : 00000000 00000001 00000002
                       r0       r1       r5    
  */  
  ARM state - stack 관련 Multiple Register Transfer / BL
  Thumb state - Push/Pop / BLX
  
  push {r4, r14}
  ...
  pop {r4, r14}

일반 Symbol과는 달리 로컬변수는 달리 Stack에 저장되니깐 개인 Address가 없다. 그래서 함수 내에서만 유지된다.
Symbol이라 함은 Physical 주소를 점유 - 함수의 이름

int (* function)(int a);
int recipe(int a)
  function = recipe or &recipe // recipe() - X

int (* function[4])(int, int) = { plus, minus, multiply, divide }
  function[2](1,3) -> multiply(1,3)


% RTOS 와 Kernel
RTOS - 기본적으로 Multi Tasking과 Interrupt 처리 기능을 가진다. 
  Hard : 응답시간 자체가 Functional Requirement가 됩 - 보통 군사용 기기
  Soft : 최대한 빨리 응답하기만 하면 요구사항을 맞출 수 있다. - 보통 우리가 다루는 RTOS
    리눅스도 Preemption Scheduling Policy 채용

% Task 구조와 Signal
Task > Process, Task > Thread
Process는 자신 만의 고유한 Memory Space를 할당받는다.
Thread는 모든 주소 공간이 공유






